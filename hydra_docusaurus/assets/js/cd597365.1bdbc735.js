"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[597],{3023:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"hydra-js-client/kuber-provider/waitForUtxoConsumption","title":"waitForUtxoConsumption","description":"waitForUtxoConsumption waits for a specific transaction output (UTxO) to be consumed (spent) on the blockchain. It will not return if the txHash#index is available on chain, and perform background poll, unless it is is consumed.","source":"@site/docs/hydra-js-client/kuber-provider/waitForUtxoConsumption.md","sourceDirName":"hydra-js-client/kuber-provider","slug":"/hydra-js-client/kuber-provider/waitForUtxoConsumption","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/kuber-provider/waitForUtxoConsumption","draft":false,"unlisted":false,"editUrl":"https://github.com/dQuadrant/kuber/docs/hydra-js-client/kuber-provider/waitForUtxoConsumption.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"sidebar_label":"waitForUtxoConsumption"},"sidebar":"hydraJsClient","previous":{"title":"buildAndSubmitWithWallet","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/kuber-provider/buildAndSubmitWithWallet"},"next":{"title":"waitForTxConfirmation","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/kuber-provider/waitForTxConfirmation"}}');var i=t(4848),s=t(8453);const r={sidebar_position:7,sidebar_label:"waitForUtxoConsumption"},a="waitForUtxoConsumption",l={},d=[{value:"Usage",id:"usage",level:2},{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Example",id:"example",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"waitforutxoconsumption",children:"waitForUtxoConsumption"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"waitForUtxoConsumption"})," waits for a specific transaction output (UTxO) to be consumed (spent) on the blockchain. It will not return if the ",(0,i.jsx)(e.code,{children:"txHash#index"})," is available on chain, and perform background poll, unless it is is consumed."]}),"\n",(0,i.jsx)(e.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"You build a transaction that consumes an input."}),"\n",(0,i.jsx)(e.li,{children:"You submit the transacition on-chain."}),"\n",(0,i.jsxs)(e.li,{children:["Now now you ",(0,i.jsx)(e.code,{children:"waitForUtxoConsumption"})," on the input that you spent."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"async waitForUtxoConsumption(\n  txin: TxInput,\n  timeoutMs: number = 80000,\n  logPoll: boolean = false,\n  pollIntervalMs: number = 5000,\n): Promise<number>\n"})}),"\n",(0,i.jsx)(e.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"txin"}),": The ",(0,i.jsx)(e.code,{children:"TxInput"})," object representing the UTxO to wait for."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"timeoutMs"}),": An optional ",(0,i.jsx)(e.code,{children:"number"})," representing the maximum time in milliseconds to wait. Defaults to ",(0,i.jsx)(e.code,{children:"80000"})," (80 seconds)."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"logPoll"}),": An optional ",(0,i.jsx)(e.code,{children:"boolean"})," indicating whether to log the polling status. Defaults to ",(0,i.jsx)(e.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"pollIntervalMs"}),": An optional ",(0,i.jsx)(e.code,{children:"number"})," representing the interval in milliseconds to poll for the UTxO. Defaults to ",(0,i.jsx)(e.code,{children:"5000"})," (5 seconds)."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"returns",children:"Returns"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.code,{children:"Promise"})," that resolves with the total time spent waiting in milliseconds when the UTxO vanishes."]}),"\n",(0,i.jsx)(e.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'import { KuberHydraApiProvider } from "kuber-client";\nimport { loadCrypto, Ed25519Key, Value } from "libcardano";\nimport { ShelleyWallet, Cip30ShelleyWallet } from "libcardano-wallet";\nimport { readFileSync } from "fs";\nimport { TxInput } from "libcardano/cardano/serialization/txinout";\n\nasync function main() {\n  await loadCrypto();\n\n  const hydra = new KuberHydraApiProvider("http://localhost:8081"); // Replace with your Hydra API URL\n\n  // Load test wallet signing key\n  const testWalletSigningKey = await Ed25519Key.fromCardanoCliJson(\n    JSON.parse(readFileSync(process.env.HOME + "/.cardano/preview/hydra-0/credentials/funds.sk", "utf-8")),\n  );\n\n  // Setup libcardano crypto and Shelley wallet\n  const shelleyWallet = new ShelleyWallet(testWalletSigningKey);\n  const cip30Wallet = new Cip30ShelleyWallet(hydra, hydra, shelleyWallet, 0);\n  const walletAddress = (await cip30Wallet.getChangeAddress()).toBech32();\n\n  console.log("Wallet Address:", walletAddress);\n\n  // Query UTxOs from the wallet\n  const utxos = await hydra.queryUTxOByAddress(walletAddress);\n  if (utxos.length === 0) {\n    console.log("No UTxOs found for the wallet address. Please ensure the wallet has funds.");\n    return;\n  }\n\n  // Select a UTxO to spend\n  const utxoToSpend = utxos[0];\n  const txInputToWatch: TxInput = {\n    txHash: utxoToSpend.txIn.txHash,\n    index: utxoToSpend.txIn.index,\n  };\n\n  // Define a simple transaction to spend the UTxO\n  const transaction = {\n    inputs: [{ txIn: `${txInputToWatch.txHash.toString(\'hex\')}#${txInputToWatch.index}` }],\n    outputs: [{ address: walletAddress, value: "1_000_000" }], // Send 1 ADA back to self\n  };\n\n  try {\n    console.log("Building, signing, and submitting transaction to consume UTxO...");\n    const txHash = await hydra.buildAndSubmitWithWallet(cip30Wallet, transaction);\n    console.log("Transaction submitted. Hash:", txHash);\n\n    console.log(`Waiting for UTxO ${txInputToWatch.txHash.toString(\'hex\')}#${txInputToWatch.index} to be consumed...`);\n    const timeWaited = await hydra.waitForUtxoConsumption(txInputToWatch, 180000, true); // Wait up to 3 minutes, log progress\n    console.log(`UTxO consumed after ${timeWaited} ms.`);\n  } catch (error) {\n    console.error("Error in transaction or waiting for UTxO consumption:", error);\n  }\n}\n\nmain();\n'})})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);