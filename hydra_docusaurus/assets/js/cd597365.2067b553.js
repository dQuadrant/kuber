"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[597],{3023:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"hydra-js-client/kuber-provider/waitForUtxoConsumption","title":"waitForUtxoConsumption","description":"waitForUtxoConsumption waits for a specific transaction output (UTxO) to be consumed (spent) on the blockchain. It will not return if the txHash#index is available on chain, and perform background poll, unless it is is consumed.","source":"@site/docs/hydra-js-client/kuber-provider/waitForUtxoConsumption.md","sourceDirName":"hydra-js-client/kuber-provider","slug":"/hydra-js-client/kuber-provider/waitForUtxoConsumption","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/kuber-provider/waitForUtxoConsumption","draft":false,"unlisted":false,"editUrl":"https://github.com/dQuadrant/kuber/tree/feat/hydra/docs/hydra-js-client/kuber-provider/waitForUtxoConsumption.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"sidebar_label":"waitForUtxoConsumption"},"sidebar":"hydraJsClient","previous":{"title":"buildAndSubmitWithWallet","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/kuber-provider/buildAndSubmitWithWallet"},"next":{"title":"waitForTxConfirmation","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/kuber-provider/waitForTxConfirmation"}}');var i=t(4848),s=t(8453);const r={sidebar_position:7,sidebar_label:"waitForUtxoConsumption"},a="waitForUtxoConsumption",l={},d=[{value:"Usage",id:"usage",level:2},{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Example",id:"example",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"waitforutxoconsumption",children:"waitForUtxoConsumption"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"waitForUtxoConsumption"})," waits for a specific transaction output (UTxO) to be consumed (spent) on the blockchain. It will not return if the ",(0,i.jsx)(n.code,{children:"txHash#index"})," is available on chain, and perform background poll, unless it is is consumed."]}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You build a transaction that consumes an input."}),"\n",(0,i.jsx)(n.li,{children:"You submit the transacition on-chain."}),"\n",(0,i.jsxs)(n.li,{children:["Now now you ",(0,i.jsx)(n.code,{children:"waitForUtxoConsumption"})," on the input that you spent."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"async waitForUtxoConsumption(\n  txin: TxInput,\n  timeoutMs: number = 80000,\n  logPoll: boolean = false,\n  pollIntervalMs: number = 5000,\n): Promise<number>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"txin"}),": The ",(0,i.jsx)(n.code,{children:"TxInput"})," object representing the UTxO to wait for."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"timeoutMs"}),": An optional ",(0,i.jsx)(n.code,{children:"number"})," representing the maximum time in milliseconds to wait. Defaults to ",(0,i.jsx)(n.code,{children:"80000"})," (80 seconds)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"logPoll"}),": An optional ",(0,i.jsx)(n.code,{children:"boolean"})," indicating whether to log the polling status. Defaults to ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pollIntervalMs"}),": An optional ",(0,i.jsx)(n.code,{children:"number"})," representing the interval in milliseconds to poll for the UTxO. Defaults to ",(0,i.jsx)(n.code,{children:"5000"})," (5 seconds)."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Promise"})," that resolves with the total time spent waiting in milliseconds when the UTxO vanishes."]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { KuberHydraApiProvider } from "kuber-client";\nimport { loadCrypto, Ed25519Key, Value } from "libcardano";\nimport { ShelleyWallet, Cip30ShelleyWallet } from "libcardano-wallet";\nimport { readFileSync } from "fs";\nimport { TxInput } from "libcardano/cardano/serialization/txinout";\n\nasync function main() {\n  await loadCrypto();\n\n  const hydra = new KuberHydraApiProvider("http://localhost:8081"); // Replace with your Hydra API URL\n\n  // Load test wallet signing key\n  const testWalletSigningKey = await Ed25519Key.fromCardanoCliJson(\n    JSON.parse(readFileSync(process.env.HOME + "/.cardano/preview/hydra-0/credentials/funds.sk", "utf-8")),\n  );\n\n  // Setup libcardano crypto and Shelley wallet\n  const shelleyWallet = new ShelleyWallet(testWalletSigningKey);\n  const cip30Wallet = new Cip30ShelleyWallet(hydra, hydra, shelleyWallet, 0);\n  const walletAddress = (await cip30Wallet.getChangeAddress()).toBech32();\n\n  console.log("Wallet Address:", walletAddress);\n\n  // Query UTxOs from the wallet\n  const utxos = await hydra.queryUTxOByAddress(walletAddress);\n  if (utxos.length === 0) {\n    console.log("No UTxOs found for the wallet address. Please ensure the wallet has funds.");\n    return;\n  }\n\n  // Select a UTxO to spend\n  const utxoToSpend = utxos[0];\n  const txInputToWatch: TxInput = {\n    txHash: utxoToSpend.txIn.txHash,\n    index: utxoToSpend.txIn.index,\n  };\n\n  // Define a simple transaction to spend the UTxO\n  const transaction = {\n    inputs: [{ txIn: `${txInputToWatch.txHash.toString(\'hex\')}#${txInputToWatch.index}` }],\n    outputs: [{ address: walletAddress, value: "1_000_000" }], // Send 1 ADA back to self\n  };\n\n  try {\n    console.log("Building, signing, and submitting transaction to consume UTxO...");\n    const txHash = await hydra.buildAndSubmitWithWallet(cip30Wallet, transaction);\n    console.log("Transaction submitted. Hash:", txHash);\n\n    console.log(`Waiting for UTxO ${txInputToWatch.txHash.toString(\'hex\')}#${txInputToWatch.index} to be consumed...`);\n    const timeWaited = await hydra.waitForUtxoConsumption(txInputToWatch, 180000, true); // Wait up to 3 minutes, log progress\n    console.log(`UTxO consumed after ${timeWaited} ms.`);\n  } catch (error) {\n    console.error("Error in transaction or waiting for UTxO consumption:", error);\n  }\n}\n\nmain();\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);