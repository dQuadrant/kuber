"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3801],{8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var a=t(6540);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}},8749:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"hydra-js-client/examples/full-end-to-end-example","title":"Full End-to-End Hydra Flow (Devnet + kuber-hydra)","description":"This guide is for developers who want to try Cardano Hydra Layer 2 quickly, without spending days wiring node APIs, keys, and transaction flow manually.","source":"@site/docs/hydra-js-client/examples/full-end-to-end-example.md","sourceDirName":"hydra-js-client/examples","slug":"/hydra-js-client/examples/full-end-to-end-example","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/examples/full-end-to-end-example","draft":false,"unlisted":false,"editUrl":"https://github.com/dQuadrant/kuber/docs/hydra-js-client/examples/full-end-to-end-example.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"sidebar_label":"Full End-to-End Example"},"sidebar":"hydraJsClient","previous":{"title":"Minting Native Tokens","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/examples/minting-native-tokens"},"next":{"title":"Query UTxOs","permalink":"/kuber/hydra_docusaurus/docs/hydra-js-client/queryUtxo"}}');var s=t(4848),r=t(8453);const i={sidebar_position:5,sidebar_label:"Full End-to-End Example"},l="Full End-to-End Hydra Flow (Devnet + kuber-hydra)",o={},d=[{value:"Why use Hydra L2?",id:"why-use-hydra-l2",level:2},{value:"Why use <code>kuber-hydra</code>?",id:"why-use-kuber-hydra",level:2},{value:"What this full example demonstrates",id:"what-this-full-example-demonstrates",level:2},{value:"Prerequisites (minimal)",id:"prerequisites-minimal",level:2},{value:"Quick start (easy path)",id:"quick-start-easy-path",level:2},{value:"1) Start a clean devnet",id:"1-start-a-clean-devnet",level:3},{value:"2) Install example dependencies",id:"2-install-example-dependencies",level:3},{value:"3) Run the full E2E flow",id:"3-run-the-full-e2e-flow",level:3},{value:"What you should expect",id:"what-you-should-expect",level:2},{value:"Script behavior (high level)",id:"script-behavior-high-level",level:2},{value:"Network and parties",id:"network-and-parties",level:3},{value:"Deterministic start",id:"deterministic-start",level:3},{value:"Head preparation",id:"head-preparation",level:3},{value:"In-head transactions",id:"in-head-transactions",level:3},{value:"Close and fanout",id:"close-and-fanout",level:3},{value:"Settlement verification",id:"settlement-verification",level:3},{value:"How this helps your own project",id:"how-this-helps-your-own-project",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Full E2E example code",id:"full-e2e-example-code",level:2},{value:"Example Package.json",id:"example-packagejson",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"full-end-to-end-hydra-flow-devnet--kuber-hydra",children:"Full End-to-End Hydra Flow (Devnet + kuber-hydra)"})}),"\n",(0,s.jsx)(n.p,{children:"This guide is for developers who want to try Cardano Hydra Layer 2 quickly, without spending days wiring node APIs, keys, and transaction flow manually."}),"\n",(0,s.jsx)(n.p,{children:"It is based on:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"kuber-hydra/hydra-example/hydra-e2e.ts"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"kuber-hydra/devnet/reset-cluster.sh"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"why-use-hydra-l2",children:"Why use Hydra L2?"}),"\n",(0,s.jsx)(n.p,{children:"Hydra gives you a fast off-chain execution environment (a Hydra Head) while still settling final results back to Cardano L1."}),"\n",(0,s.jsx)(n.p,{children:"Typical use-cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High-frequency transactions"}),": many transfers between participants with lower latency."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interactive apps"}),": games, micro-payments, and collaborative workflows where quick finality matters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batching L1 interaction"}),": run activity in Hydra, settle net result to L1 at close/fanout."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In simple terms: Hydra is useful when your users need speed and responsiveness, but you still want L1 settlement guarantees."}),"\n",(0,s.jsxs)(n.h2,{id:"why-use-kuber-hydra",children:["Why use ",(0,s.jsx)(n.code,{children:"kuber-hydra"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["Directly integrating with Hydra + Cardano can be operationally heavy. ",(0,s.jsx)(n.code,{children:"kuber-hydra"})," makes this easier by exposing a familiar API for both L1 and Hydra workflows."]}),"\n",(0,s.jsxs)(n.p,{children:["With ",(0,s.jsx)(n.code,{children:"kuber-hydra"}),", developers can:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reuse a consistent transaction-building model."}),"\n",(0,s.jsx)(n.li,{children:"Use simple HTTP relay endpoints for Alice/Bob/Carol."}),"\n",(0,s.jsx)(n.li,{children:"Build, sign, submit, and query with less low-level boilerplate."}),"\n",(0,s.jsx)(n.li,{children:"Start from a working devnet and iterate quickly."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"what-this-full-example-demonstrates",children:"What this full example demonstrates"}),"\n",(0,s.jsx)(n.p,{children:"The script runs the complete lifecycle end-to-end:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Initialize/open head"}),"\n",(0,s.jsx)(n.li,{children:"Fund participants if needed"}),"\n",(0,s.jsx)(n.li,{children:"Commit UTxOs from Alice, Bob, Carol"}),"\n",(0,s.jsx)(n.li,{children:"Submit in-head transactions"}),"\n",(0,s.jsx)(n.li,{children:"Close head and fanout"}),"\n",(0,s.jsx)(n.li,{children:"Verify L1 settlement"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This gives you a realistic baseline for production-oriented flows: open -> transact -> close -> settle."}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites-minimal",children:"Prerequisites (minimal)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Docker running locally"}),"\n",(0,s.jsx)(n.li,{children:"Node.js 18+ (or compatible)"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kuber"})," repository cloned locally"]}),"\n",(0,s.jsxs)(n.li,{children:["Devnet ports available:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"8082"})," (Alice relay)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"8083"})," (Bob relay)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"8084"})," (Carol relay)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"quick-start-easy-path",children:"Quick start (easy path)"}),"\n",(0,s.jsx)(n.h3,{id:"1-start-a-clean-devnet",children:"1) Start a clean devnet"}),"\n",(0,s.jsxs)(n.p,{children:["From ",(0,s.jsx)(n.code,{children:"kuber-hydra/devnet"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"./reset-cluster.sh\ndocker compose ps\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You do not need to run each setup script manually. ",(0,s.jsx)(n.code,{children:"reset-cluster.sh"})," already does it for you."]}),"\n",(0,s.jsx)(n.p,{children:"Behind the scenes it:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Recreates runtime and credentials"}),"\n",(0,s.jsx)(n.li,{children:"Starts cardano-node"}),"\n",(0,s.jsx)(n.li,{children:"Seeds participant wallets"}),"\n",(0,s.jsx)(n.li,{children:"Publishes Hydra scripts"}),"\n",(0,s.jsxs)(n.li,{children:["Starts all services (",(0,s.jsx)(n.code,{children:"cardano-node"}),", ",(0,s.jsx)(n.code,{children:"hydra-node-1..3"}),", ",(0,s.jsx)(n.code,{children:"kuber-hydra-1..3"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-install-example-dependencies",children:"2) Install example dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["From ",(0,s.jsx)(n.code,{children:"kuber-hydra/hydra-example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pnpm install\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The example uses ",(0,s.jsx)(n.code,{children:"tsx"})," and ",(0,s.jsx)(n.code,{children:"kuber-client"})," from ",(0,s.jsx)(n.code,{children:"hydra-example/package.json"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"3-run-the-full-e2e-flow",children:"3) Run the full E2E flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd kuber-hydra/hydra-example\nnpx tsx hydra-e2e.ts\n"})}),"\n",(0,s.jsx)(n.h2,{id:"what-you-should-expect",children:"What you should expect"}),"\n",(0,s.jsx)(n.p,{children:"On success, you will see logs showing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Head reached ",(0,s.jsx)(n.code,{children:"Open"})]}),"\n",(0,s.jsx)(n.li,{children:"Transactions submitted inside Hydra"}),"\n",(0,s.jsxs)(n.li,{children:["Head moved to ",(0,s.jsx)(n.code,{children:"Closed"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fanout"})," completed"]}),"\n",(0,s.jsx)(n.li,{children:"Final L1 balances printed for Alice/Bob/Carol"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This confirms the full L2-to-L1 cycle worked."}),"\n",(0,s.jsx)(n.h2,{id:"script-behavior-high-level",children:"Script behavior (high level)"}),"\n",(0,s.jsx)(n.h3,{id:"network-and-parties",children:"Network and parties"}),"\n",(0,s.jsx)(n.p,{children:"The script targets three relays:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Alice: ",(0,s.jsx)(n.code,{children:"http://localhost:8082"})]}),"\n",(0,s.jsxs)(n.li,{children:["Bob: ",(0,s.jsx)(n.code,{children:"http://localhost:8083"})]}),"\n",(0,s.jsxs)(n.li,{children:["Carol: ",(0,s.jsx)(n.code,{children:"http://localhost:8084"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Signing keys are loaded from:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"kuber-hydra/devnet/credentials/alice-hydra.sk"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"kuber-hydra/devnet/credentials/bob-hydra.sk"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"kuber-hydra/devnet/credentials/carol-hydra.sk"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"deterministic-start",children:"Deterministic start"}),"\n",(0,s.jsxs)(n.p,{children:["At flow start, ",(0,s.jsx)(n.code,{children:"ensureFreshDevnetHead()"})," executes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd kuber-hydra/devnet && ./reset-cluster.sh\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then it waits until all three relays respond to ",(0,s.jsx)(n.code,{children:"queryHeadState"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"head-preparation",children:"Head preparation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ensureHeadOpenAndCommitted()"})," handles different initial states:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open"}),": proceeds directly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Closed"}),": waits for contestation deadline, tries ",(0,s.jsx)(n.code,{children:"fanout"}),", verifies settlement, exits as recovered flow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Idle/other"}),": initializes head and commits missing parties"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If a party does not have enough L1 balance, the script funds from faucet before commit."}),"\n",(0,s.jsx)(n.h3,{id:"in-head-transactions",children:"In-head transactions"}),"\n",(0,s.jsx)(n.p,{children:"After head is open, the script performs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Alice -> Bob: ",(0,s.jsx)(n.code,{children:"1A"})]}),"\n",(0,s.jsxs)(n.li,{children:["Bob -> Carol: ",(0,s.jsx)(n.code,{children:"1A"})]}),"\n",(0,s.jsxs)(n.li,{children:["Carol -> Alice: ",(0,s.jsx)(n.code,{children:"1A"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It retries on transient Hydra submission timing issues (snapshot timing / cluster timing mismatches)."}),"\n",(0,s.jsx)(n.h3,{id:"close-and-fanout",children:"Close and fanout"}),"\n",(0,s.jsx)(n.p,{children:"The script:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Ensures close collateral exists on L1"}),"\n",(0,s.jsx)(n.li,{children:"Attempts close via Alice, then Bob, then Carol relay"}),"\n",(0,s.jsxs)(n.li,{children:["Waits for ",(0,s.jsx)(n.code,{children:"Closed"})]}),"\n",(0,s.jsx)(n.li,{children:"Waits until contestation deadline"}),"\n",(0,s.jsxs)(n.li,{children:["Calls ",(0,s.jsx)(n.code,{children:"fanout"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"settlement-verification",children:"Settlement verification"}),"\n",(0,s.jsx)(n.p,{children:"Finally, it queries each party L1 address and logs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"UTxO count"}),"\n",(0,s.jsx)(n.li,{children:"Total ADA settled after fanout"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"how-this-helps-your-own-project",children:"How this helps your own project"}),"\n",(0,s.jsx)(n.p,{children:"Use this example as a template for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Opening a head for a known participant set"}),"\n",(0,s.jsx)(n.li,{children:"Committing initial user liquidity"}),"\n",(0,s.jsx)(n.li,{children:"Running your app logic as Hydra transactions"}),"\n",(0,s.jsx)(n.li,{children:"Settling final state back to L1"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A practical approach is to keep your domain logic separate, and call ",(0,s.jsx)(n.code,{children:"kuber-hydra"})," only for lifecycle + transaction operations."]}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If relays are not reachable, run ",(0,s.jsx)(n.code,{children:"docker compose ps"})," in ",(0,s.jsx)(n.code,{children:"kuber-hydra/devnet"})," and ensure ports ",(0,s.jsx)(n.code,{children:"8082-8084"})," are up."]}),"\n",(0,s.jsx)(n.li,{children:"If close fails due to collateral, re-run and allow faucet funding to complete."}),"\n",(0,s.jsxs)(n.li,{children:["If a previous head is stuck in ",(0,s.jsx)(n.code,{children:"Closed"}),", the script tries automatic recovery/fanout; if recovery fails, run ",(0,s.jsx)(n.code,{children:"./reset-cluster.sh"})," and retry."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"full-e2e-example-code",children:"Full E2E example code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { readFileSync } from "fs";\nimport { execSync } from "child_process";\nimport { loadCrypto, Ed25519Key, Value } from "libcardano";\nimport { ShelleyWallet, Cip30ShelleyWallet } from "libcardano-wallet";\nimport { KuberHydraApiProvider } from "kuber-client"; // Adjust path as needed\nimport { UTxO } from "libcardano/cardano/serialization";\n\n// Set your work directory and paths according to your local setup. \n// This example assumes a specific structure for the devnet, so adjust as necessary for your environment. \nconst WORK_DIR = process.env.HOME + "/work/kuber/kuber-hydra/devnet";\n\nconst hydraAlice = new KuberHydraApiProvider("http://localhost:8082");\nconst hydraBob = new KuberHydraApiProvider("http://localhost:8083");\nconst hydraCarol = new KuberHydraApiProvider("http://localhost:8084");\n\ntype PartyConfig = {\n  name: string;\n  skPath: string;\n  hydra: KuberHydraApiProvider;\n};\n\ntype PartyRuntime = PartyConfig & {\n  wallet: Cip30ShelleyWallet;\n  address: string;\n  pubKeyHex?: string;\n};\n\nconst PARTIES: PartyConfig[] = [\n  { name: "Alice", skPath: WORK_DIR + "/credentials/alice-hydra.sk", hydra: hydraAlice },\n  { name: "Bob", skPath: WORK_DIR + "/credentials/bob-hydra.sk", hydra: hydraBob },\n  { name: "Carol", skPath: WORK_DIR + "/credentials/carol-hydra.sk", hydra: hydraCarol },\n];\n\nconst DEVNET_RELAYS = [8082, 8083, 8084];\n\nasync function waitForRelayHealth(timeoutMs: number = 120000): Promise<void> {\n  const start = Date.now();\n\n  while (Date.now() - start < timeoutMs) {\n    const checks = await Promise.all(\n      DEVNET_RELAYS.map(async (port) => {\n        try {\n          const state = await new KuberHydraApiProvider(`http://localhost:${port}`).queryHeadState();\n          return typeof state?.state === "string";\n        } catch {\n          return false;\n        }\n      }),\n    );\n\n    if (checks.every(Boolean)) {\n      return;\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  }\n\n  throw new Error(`Timed out waiting for relays ${DEVNET_RELAYS.join(", ")} to become healthy.`);\n}\n\nasync function ensureFreshDevnetHead(): Promise<void> {\n  console.log("Resetting devnet at flow start for deterministic E2E execution...");\n  execSync(`cd ${WORK_DIR} && ./reset-cluster.sh`, { stdio: "inherit" });\n  await waitForRelayHealth();\n}\n\nasync function queryUtxosByAddress(address: string): Promise<UTxO[]> {\n  const utxos = await hydraAlice.l1Api.queryUTxOByAddress(address);\n  console.log(`\\nUTxOs for address ${address}:`);\n  if (utxos.length === 0) {\n    console.log("No UTxOs found for this address.");\n    return [];\n  }\n  utxos.forEach((utxo) => {\n    const txIn = utxo.txIn;\n    const balance = Number(utxo.txOut.value.lovelace) / 1_000_000; // Convert from lovelace to ADA\n    console.log(`${txIn.txHash.toString("hex")}#${txIn.index} - ${balance} ADA`);\n  });\n  return utxos;\n}\n\nasync function getTotalAdaBalanceByAddress(address: string): Promise<number> {\n  const utxos = await hydraAlice.l1Api.queryUTxOByAddress(address);\n  let totalBalance = 0;\n  utxos.forEach((utxo) => {\n    totalBalance += Number(utxo.txOut.value.lovelace);\n  });\n  console.log(`\\nTotal balance for address ${address}: ${totalBalance / 1_000_000} ADA`);\n  return totalBalance / 1_000_000;\n}\n\nasync function getCip30WalletFromSkFile(skFilePath: string, hydra: KuberHydraApiProvider): Promise<Cip30ShelleyWallet> {\n  const skFile = readFileSync(skFilePath, "utf-8");\n  const signingKey = await Ed25519Key.fromCardanoCliJson(\n    JSON.parse(skFile),\n  );\n  const shelleyWallet = new ShelleyWallet(signingKey);\n  return new Cip30ShelleyWallet(hydra, hydra, shelleyWallet, 0);\n}\n\nasync function waitForBalance(address: string, minimumBalance: number, timeout: number = 120000): Promise<void> {\n  const startTime = Date.now();\n  while (Date.now() - startTime < timeout) {\n    const balance = await getTotalAdaBalanceByAddress(address);\n    if (balance >= minimumBalance) {\n      console.log(`Balance of ${balance} ADA reached for address ${address}`);\n      return;\n    }\n    console.log(`Current balance ${balance} ADA is less than required ${minimumBalance} ADA. Retrying in 1 second...`);\n    await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before retrying\n  }\n  throw new Error(`Timeout: Balance did not reach ${minimumBalance} ADA for address ${address} within ${timeout / 60000} minutes.`);\n}\n\nasync function fundWalletWithFaucet(walletAddress: string, minimumBalanceAda: number = 10, fundingAda: number = 10) {\n\n  const faucetSkPath = WORK_DIR + "/runtime/cardano-node/faucet.sk";\n  const faucetCip30Wallet = await getCip30WalletFromSkFile(faucetSkPath, hydraAlice);\n  const faucetAddress = (await faucetCip30Wallet.getChangeAddress()).toBech32();\n  console.log("Faucet Address:", faucetAddress);\n  await queryUtxosByAddress(faucetAddress);\n\n  // Get total balance of wallet before funding\n  const balance = await getTotalAdaBalanceByAddress(walletAddress);\n\n  if (balance >= minimumBalanceAda) {\n    console.log(`Wallet already has ${balance} ADA, skipping funding.`);\n    return;\n  }\n\n  const txBuilder = {\n    selections: [\n      faucetAddress, // Funding from faucet address\n    ],\n    outputs: [{ address: walletAddress, value: `${fundingAda}A` }],\n    changeAddress: faucetAddress,\n  };\n  const buildResult = await hydraAlice.l1Api.buildTx(txBuilder);\n  const signResult = await faucetCip30Wallet.signTx(buildResult.cborHex);\n  await hydraAlice.l1Api.submitTx(signResult.updatedTxBytes.toString("hex"));\n  console.log("Submitted funding transaction hash:", buildResult.hash);\n\n  // // // Wait for the transaction to be confirmed\n  await waitForBalance(walletAddress, minimumBalanceAda, 120000);\n\n}\n\nasync function getMaxUtxoAdaByAddress(address: string): Promise<number> {\n  const utxos = await hydraAlice.l1Api.queryUTxOByAddress(address);\n  if (utxos.length === 0) return 0;\n  const maxLovelace = utxos.reduce((max, utxo) => {\n    const value = Number(utxo.txOut.value.lovelace);\n    return value > max ? value : max;\n  }, 0);\n  return maxLovelace / 1_000_000;\n}\n\nasync function ensureCloseCollateral(parties: PartyRuntime[]): Promise<void> {\n  const minimumLargestUtxoAda = 8;\n\n  for (const party of parties) {\n    const largestUtxoAda = await getMaxUtxoAdaByAddress(party.address);\n    if (largestUtxoAda >= minimumLargestUtxoAda) {\n      continue;\n    }\n\n    console.log(\n      `${party.name} largest L1 UTxO is ${largestUtxoAda} ADA (< ${minimumLargestUtxoAda} ADA). Funding collateral buffer...`,\n    );\n    await fundWalletWithFaucet(party.address, 12, 12);\n\n    const updatedLargestUtxoAda = await getMaxUtxoAdaByAddress(party.address);\n    if (updatedLargestUtxoAda < minimumLargestUtxoAda) {\n      throw new Error(\n        `${party.name} still lacks a large-enough collateral UTxO after funding (largest=${updatedLargestUtxoAda} ADA).`,\n      );\n    }\n  }\n}\n\nasync function commitToHydraHead(cip30Wallet: Cip30ShelleyWallet, hydra: KuberHydraApiProvider, partyName: string) {\n  // Select UTxOs to commit (e.g., the first one with a value greater than 4 ADA)\n  const walletAddress = (await cip30Wallet.getChangeAddress()).toBech32();\n  const l1Utxos = await queryUtxosByAddress(walletAddress);\n  const selectedUtxos = l1Utxos.filter((x) => x.txOut.value.greaterThan(Value.fromString("4A")));\n  if (selectedUtxos.length === 0) {\n    throw new Error(`Not enough balance on ${walletAddress} in L1 chain for commit example`);\n  }\n  console.log(`\\nSelected UTxOs for commit (${partyName}):`);\n  selectedUtxos.forEach((utxo) => {\n    const txIn = utxo.txIn;\n    const balance = Number(utxo.txOut.value.lovelace) / 1_000_000; // Convert from lovelace to ADA\n    console.log(`${txIn.txHash.toString("hex")}#${txIn.index} - ${balance} ADA`);\n  });\n\n  const txIn = selectedUtxos[0].txIn;\n  const utxoToCommit = [`${txIn.txHash.toString("hex")}#${txIn.index}`];\n\n  // Build the commit transaction using Hydra API\n  const commitResult = await hydra.commit({ utxos: utxoToCommit });\n  console.log(`Transaction to be signed (${partyName}):`, commitResult.hash);\n\n  // Sign the transaction using the CIP-30 wallet\n  const signResult = await cip30Wallet.signTx(commitResult.cborHex);\n\n  // Submit the signed transaction to the L1 chain\n  await hydra.l1Api.submitTx(signResult.updatedTxBytes.toString("hex"));\n  console.log(`Submitted Commit transaction hash (${partyName}):`, commitResult.hash);\n\n  // // Wait for the transaction to be confirmed and head state to change\n  await hydra.l1Api.waitForUtxoConsumption(selectedUtxos[0].txIn, 280000);\n  console.log("Commit transaction confirmed.");\n\n}\n\nasync function buildPartyRuntime(): Promise<PartyRuntime[]> {\n  const runtime: PartyRuntime[] = [];\n  for (const party of PARTIES) {\n    const wallet = await getCip30WalletFromSkFile(party.skPath, party.hydra);\n    const address = (await wallet.getChangeAddress()).toBech32();\n    const pubKeyHex = wallet?.shelleyWallet?.paymentKey?.public?.toString("hex");\n    runtime.push({ ...party, wallet, address, pubKeyHex });\n  }\n  return runtime;\n}\n\nasync function prepareHeadForTestFlow(parties: PartyRuntime[]): Promise<void> {\n  const initialHeadState = await hydraAlice.queryHeadState();\n  console.log("Current head state:", initialHeadState.state);\n\n  if (initialHeadState.state !== "Idle") {\n    throw new Error(`Expected Idle after reset, got ${initialHeadState.state}`);\n  }\n\n  await hydraAlice.initialize(true);\n  console.log("Hydra head initialized from Idle.");\n\n  for (const party of parties) {\n    console.log(`${party.name} Address:`, party.address);\n    await fundWalletWithFaucet(party.address);\n    await commitToHydraHead(party.wallet, party.hydra, party.name);\n  }\n\n  const openWaitMs = await hydraAlice.waitForHeadState("Open", 300000, true, 3000);\n  console.log(`Hydra head is OPEN (waited ${openWaitMs} ms).`);\n}\n\nasync function submitHydraTransactions(parties: PartyRuntime[]): Promise<void> {\n  const byName = Object.fromEntries(parties.map((x) => [x.name, x])) as Record<string, PartyRuntime>;\n\n  const txPlan = [\n    { from: "Alice", to: "Bob", value: "1A" },\n    { from: "Bob", to: "Carol", value: "1A" },\n    { from: "Carol", to: "Alice", value: "1A" },\n  ];\n\n  console.log("Submitting Hydra head transactions between all parties...");\n  for (const tx of txPlan) {\n    const sender = byName[tx.from];\n    const receiver = byName[tx.to];\n    const maxRetries = 8;\n    let submittedHash = "";\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const builtTx = await hydraAlice.buildWithWallet(sender.wallet, {\n          selections: [sender.address],\n          outputs: [{ address: receiver.address, value: tx.value }],\n          changeAddress: sender.address,\n        });\n        const signedTx = await sender.wallet.signTx(builtTx.cborHex, true);\n\n        try {\n          await hydraAlice.submitTx(signedTx.updatedTxBytes.toString("hex"));\n        } catch (error: any) {\n          const type = error?.data?.type;\n          const message = String(error?.data?.message ?? error?.message ?? "");\n          const isAcceptedButReportedAsError =\n            type === "TxSubmissionError" && message.includes("Request created");\n          if (!isAcceptedButReportedAsError) {\n            throw error;\n          }\n          console.log(`Hydra submit accepted by relay with async response (${tx.from} -> ${tx.to}).`);\n        }\n\n        submittedHash = builtTx.hash ?? "";\n        console.log(`Hydra tx submitted: ${tx.from} -> ${tx.to} (${tx.value}), hash=${submittedHash}`);\n        break;\n      } catch (error: any) {\n        const type = error?.data?.type;\n        const message = String(error?.data?.message ?? error?.message ?? "");\n        const isSnapshotTimingError =\n          type === "TxSubmissionError" && (message.includes("SnapshotConfirmed") || message.includes("NetworkClusterIDMismatch"));\n\n        if (!isSnapshotTimingError || attempt === maxRetries) {\n          throw error;\n        }\n\n        console.log(`Hydra tx retry (${attempt}/${maxRetries}) for ${tx.from} -> ${tx.to} due to snapshot timing. Waiting 4s...`);\n        await new Promise((resolve) => setTimeout(resolve, 4000));\n      }\n    }\n\n    if (!submittedHash) {\n      throw new Error(`Failed to submit Hydra tx from ${tx.from} to ${tx.to}`);\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 2000));\n  }\n\n  const headUtxos = await hydraAlice.queryUtxos();\n  console.log(`Hydra head UTxO count after transfers: ${headUtxos.length}`);\n}\n\nasync function closeAndFanoutHead(parties: PartyRuntime[]): Promise<void> {\n  const beforeClose = await hydraAlice.queryHeadState();\n  if (beforeClose.state !== "Open") {\n    throw new Error(`Expected head state Open before close, got ${beforeClose.state}`);\n  }\n\n  await ensureCloseCollateral(parties);\n\n  console.log("Closing Hydra head...");\n  const closeProviders = [\n    { name: "Alice relay", hydra: hydraAlice },\n    { name: "Bob relay", hydra: hydraBob },\n    { name: "Carol relay", hydra: hydraCarol },\n  ];\n\n  let closeSucceeded = false;\n  let closeErrors: string[] = [];\n\n  for (const provider of closeProviders) {\n    try {\n      console.log(`Attempting close via ${provider.name}...`);\n      await provider.hydra.close(true);\n      closeSucceeded = true;\n      console.log(`Close accepted via ${provider.name}.`);\n      break;\n    } catch (error: any) {\n      console.log(error);\n      const message = String(error?.message ?? "Unknown close error");\n      closeErrors.push(`${provider.name}: ${message}`);\n\n      const currentState = await hydraAlice.queryHeadState();\n      if (currentState.state === "Closed") {\n        closeSucceeded = true;\n        console.log(`Head reached Closed after close attempt on ${provider.name}.`);\n        break;\n      }\n\n      console.log(`Close failed via ${provider.name}.`);\n    }\n  }\n\n  if (!closeSucceeded) {\n    throw new Error(`Unable to close head. Errors: ${closeErrors.join(" | ")}`);\n  }\n\n  const closedWaitMs = await hydraAlice.waitForHeadState("Closed", 300000, true, 3000);\n  const afterClose = await hydraAlice.queryHeadState();\n  console.log(`Hydra head state after close: ${afterClose.state} (waited ${closedWaitMs} ms).`);\n  if (afterClose.state !== "Closed") {\n    throw new Error(`Close failed. Expected Closed, got ${afterClose.state}`);\n  }\n\n  // Wait until the contestation deadline has passed before attempting fanout.\n  // The head may expose contestationDeadline in different fields; check both.\n  const headInfo: any = await hydraAlice.queryHead();\n  const contestationIso = headInfo?.contents?.contestationDeadline ?? headInfo?.postChainTx?.contestationDeadline ?? null;\n  if (contestationIso) {\n    const contestationDate = new Date(contestationIso);\n    const now = new Date();\n    if (contestationDate > now) {\n      const waitMs = contestationDate.getTime() - now.getTime() + 1000; // add small buffer\n      console.log(`Waiting ${Math.ceil(waitMs / 1000)}s for contestation deadline to pass before fanout...`);\n      await new Promise((r) => setTimeout(r, waitMs));\n    }\n  } else {\n    // fallback short wait if contestation deadline not available\n    console.log("No contestationDeadline found on head \u2014 sleeping 5s before fanout as fallback.");\n    await new Promise((r) => setTimeout(r, 5000));\n  }\n\n  console.log("Running fanout...");\n  await hydraAlice.fanout(true);\n  console.log("Fanout request completed.");\n}\n\nasync function verifyL1Settlement(parties: PartyRuntime[]): Promise<void> {\n  console.log("Verifying L1 UTxOs after fanout...");\n  for (const party of parties) {\n    const utxos = await hydraAlice.l1Api.queryUTxOByAddress(party.address);\n    const totalLovelace = utxos.reduce((acc, utxo) => acc + Number(utxo.txOut.value.lovelace), 0);\n    const totalAda = totalLovelace / 1_000_000;\n    console.log(`${party.name} L1 settlement: ${utxos.length} UTxO(s), ${totalAda} ADA at ${party.address}`);\n  }\n}\n\nasync function runHydraE2EFlow() {\n  await loadCrypto();\n  await ensureFreshDevnetHead();\n\n  const parties = await buildPartyRuntime();\n  await prepareHeadForTestFlow(parties);\n\n  await submitHydraTransactions(parties);\n  await closeAndFanoutHead(parties);\n  await verifyL1Settlement(parties);\n\n  const finalHeadState = await hydraAlice.queryHeadState();\n  console.log("Final head state:", finalHeadState.state);\n}\n\nrunHydraE2EFlow();\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"example-packagejson",children:"Example Package.json"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'{\n  "dependencies": {\n    "@types/node": "^25.2.3",\n    "kuber-client": "3.3.1"\n  },\n  "devDependencies": {\n    "tsx": "^4.20.3",\n    "typescript": "^5.8.3",\n    "libcardano": "2.2.8",\n    "libcardano-wallet": "2.2.8"\n  },\n  "scripts": {\n    "start": "node example.cjs",\n    "start:esm": "node example.mjs"\n  },\n  "name": "hydra-example",\n  "version": "1.0.0",\n  "main": "example.cjs",\n  "license": "MIT",\n  "type": "commonjs"\n}\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);